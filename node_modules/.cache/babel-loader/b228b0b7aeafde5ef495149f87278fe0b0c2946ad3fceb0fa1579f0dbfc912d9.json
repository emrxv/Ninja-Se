{"ast":null,"code":"/** Redraw entire canvas from model. */\n\nimport { config_6x6 } from \"../model/config\";\nexport function redrawCanvas(model, canvasObj, appObj) {\n  const ctx = canvasObj.getContext('2d');\n  if (ctx === null) {\n    return;\n  } // here for testing purposes...\n\n  // clear the canvas area before rendering the coordinates held in state\n  ctx.clearRect(0, 0, canvasObj.width, canvasObj.height);\n\n  // draws squares based on information? Perhaps you can use some of this concept\n  let size = model.board.size;\n  for (let r = 0; r < size; r++) {\n    for (let c = 0; c < size; c++) {\n      let square = model.board.grid[r][c];\n      let x = c * 50;\n      let y = r * 50;\n      let w = 50;\n      let h = 50;\n      ctx.lineWidth = 1;\n      if (square.color) {\n        ctx.fillStyle = square.color;\n      } else {\n        ctx.fillStyle = 'white';\n      }\n      ctx.fillRect(x, y, w, h);\n      ctx.strokeRect(x, y, w, h);\n    }\n  }\n\n  // THEN draw ninjase\n  let image = document.getElementById('ninjase');\n  image.onload = function () {\n    for (let r = 0; r < size; r++) {\n      for (let c = 0; c < size; c++) {\n        let square = model.board.grid[r][c];\n        if (square.color == 'pink' && r + 1 < size && c + 1 < size && model.board.grid[r + 1][c].color == 'pink' && model.board.grid[r][c + 1].color == 'pink' && model.board.grid[r + 1][c + 1].color == 'pink') {\n          let x = c * 50;\n          let y = r * 50;\n          let w = 50 * 2;\n          let h = 50 * 2;\n          ctx.drawImage(image, x, y, w, h);\n        }\n      }\n    }\n  };\n  for (let r = 0; r < size; r++) {\n    for (let c = 0; c < size; c++) {\n      let square = model.board.grid[r][c];\n      if (square.color == 'pink' && r + 1 < size && c + 1 < size && model.board.grid[r + 1][c].color == 'pink' && model.board.grid[r][c + 1].color == 'pink' && model.board.grid[r + 1][c + 1].color == 'pink') {\n        let x = c * 50;\n        let y = r * 50;\n        let w = 50 * 2;\n        let h = 50 * 2;\n        ctx.drawImage(image, x, y, w, h);\n      }\n    }\n  }\n}","map":{"version":3,"names":["config_6x6","redrawCanvas","model","canvasObj","appObj","ctx","getContext","clearRect","width","height","size","board","r","c","square","grid","x","y","w","h","lineWidth","color","fillStyle","fillRect","strokeRect","image","document","getElementById","onload","drawImage"],"sources":["/Users/emresunar/Documents/CS3733/IProj/starter/src/boundary/Boundary.js"],"sourcesContent":["/** Redraw entire canvas from model. */\n\nimport { config_6x6 } from \"../model/config\";\n\n\nexport function redrawCanvas(model, canvasObj, appObj) {\n    const ctx = canvasObj.getContext('2d');\n    if (ctx === null) { return; }    // here for testing purposes...\n    \n    // clear the canvas area before rendering the coordinates held in state\n    ctx.clearRect( 0,0, canvasObj.width, canvasObj.height);  \n\n    // draws squares based on information? Perhaps you can use some of this concept\n    let size = model.board.size\n    for (let r = 0; r < size; r++) {\n      for (let c = 0; c < size; c++) {\n        let square = model.board.grid[r][c]\n        let x = c * 50\n        let y = r * 50\n        let w = 50\n        let h = 50\n        ctx.lineWidth = 1;\n        if (square.color) {\n          ctx.fillStyle = square.color\n        } else {\n          ctx.fillStyle = 'white'\n        }\n        ctx.fillRect(x, y, w, h)\n        ctx.strokeRect(x, y, w, h)\n      }\n    }\n\n    \n    // THEN draw ninjase\n    let image = document.getElementById('ninjase');\n\n    image.onload = function () {\n      for (let r = 0; r < size; r++) {\n          for (let c = 0; c < size; c++) {\n              let square = model.board.grid[r][c];\n              if (square.color == 'pink' &&\n                  r + 1 < size && c + 1 < size &&\n                  model.board.grid[r + 1][c].color == 'pink' &&\n                  model.board.grid[r][c + 1].color == 'pink' &&\n                  model.board.grid[r + 1][c + 1].color == 'pink') {\n\n                  let x = c * 50;\n                  let y = r * 50;\n                  let w = 50 * 2;\n                  let h = 50 * 2;\n                  ctx.drawImage(image, x, y, w, h);\n              }\n          }\n      }\n  };\n\n    for (let r = 0; r < size; r++) {\n        for (let c = 0; c < size; c++) {\n            let square = model.board.grid[r][c];\n            if (square.color == 'pink' && \n                r + 1 < size && c + 1 < size &&\n                model.board.grid[r + 1][c].color == 'pink' && \n                model.board.grid[r][c + 1].color == 'pink' &&\n                model.board.grid[r + 1][c + 1].color == 'pink') {\n               \n                let x = c * (50);\n                let y = r * (50);\n                let w = 50 * 2;\n                let h = 50 * 2;\n                ctx.drawImage(image, x, y, w, h);\n            }\n        }\n    }\n\n\n\n    \n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}